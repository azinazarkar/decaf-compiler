package compiler.Parser;
import java_cup.runtime.*;
import compiler.Scanner.MyScanner;
import compiler.CodeGenerator.SymbolTable.*;
import compiler.CodeGenerator.Exceptions.*;
import compiler.CodeGenerator.SymbolTable.Utility.*;
import compiler.CodeGenerator.*;
import compiler.CodeGenerator.CodeGen.*;
import compiler.CodeGenerator.SymbolTable.Utility.*;
import compiler.Parser.Utility.ParserHelper;


parser code {:
	private MyScanner scanner;
	public parser (MyScanner scanner){
		this.scanner = scanner;
	}
:}
scan with {: return scanner.next_token(); :}
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Call, Actuals;
// non-terminals with type
nonterminal     Object Type;
nonterminal     Descriptor LValue;
nonterminal     Descriptor Expr;
nonterminal     CompileTimeDescriptor Constant;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl DeclStar;

DeclStar ::=            Decl DeclStar
						| /*epsilon*/
						;

Decl ::=                VariableDecl
						| FunctionDecl
						| ClassDecl
						| InterfaceDecl
						;

VariableDecl ::=        Variable SEMICOLON;

Variable ::=            Type:type IDENTIFIER:id {:
							if ( ParserPhase.getInstance().getPhase() == 0 ) {
								if ( type instanceof Type ) {
									Type t = (Type) type;
									String name = IDGenerator.getInstance().getNextID();
									SymbolTable.getInstance().getSymbolTable().addEntry(
										id,
										new Descriptor( name, t )
									);
									CodeGen.getInstance().addToData( name, Type.getMipsType( t ), Integer.toString( 0 ) );
								}
								else if ( type instanceof ArrayType ) {
									ArrayType t = (ArrayType) type;
									String name = IDGenerator.getInstance().getNextID();
									SymbolTable.getInstance().getSymbolTable().addEntry(
										id,
										new ArrayDescriptor( name, t )
									);
									CodeGen.getInstance().addToData( name, Type.getMipsType( t ), Integer.toString( 0 ) );
								}
							}
						:}
						;

Type ::=                INT {: RESULT = Type.INT; :}
						| DOUBLE {: RESULT = Type.DOUBLE; :}
						| BOOL {: RESULT = Type.BOOL; :}
						| STRING {: RESULT = Type.STRING; :}
						| IDENTIFIER:e {: RESULT = Type.OBJECT; :}
						| Type:t OPENCLOSEBRACKET {:
							if ( t == Type.INT || t == Type.DOUBLE || t == Type.BOOL
									|| t == Type.STRING || t == Type.OBJECT )
								RESULT = new ArrayType( (Type) t, 1 );
							else if ( t instanceof ArrayType ) {
									ArrayType temp = (ArrayType) t;
									RESULT = new ArrayType( temp.getSubType(), temp.getDimensionCount() + 1 );
								}
						:}
						;

FunctionDecl ::=        Type:t IDENTIFIER:name OPENPARENTHESIS {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 0 ) {
								SymbolTable.getInstance().makeNextAndSwitch( name );
							}
							else if ( phase == 1 ) {
								CodeGen.getInstance().addToText( name + ":\n", true );
								SymbolTable.getInstance().switchToNext();
							}
						:}
						Formals {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 0 )
								SymbolTable.getInstance().makeNextAndSwitch();
							else if ( phase == 1 )
								SymbolTable.getInstance().switchToNext();
						:} CLOSEPARENTHESIS StmtBlock {:
							SymbolTable.getInstance().goBack();
							if ( ParserPhase.getInstance().getPhase() == 1 )
								if ( SymbolTable.getInstance().getSymbolTable().getScopeName().equals( "main" )
										&& SymbolTable.getInstance().getSymbolTable().getEntryCount() == 0 ) {
	                                CodeGen.getInstance().addToText( "# Exit!" );
	                                CodeGen.getInstance().addToText( "li $v0, 10" );
	                                CodeGen.getInstance().addToText( "syscall" );
	                                CodeGen.getInstance().addEmptyLine();
	                                CodeGen.getInstance().addEmptyLine();
                                }
							SymbolTable.getInstance().goBack();
						:}
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						;

Formals ::=             Variable:v CommaVariables
						| /*epsilon*/
						;
CommaVariables ::=      COMMA Variable CommaVariables
						| /*epsilon*/
						;

ClassDecl ::=           CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES;
ClassDeclExtends ::=    EXTENDS IDENTIFIER
						| /*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
FieldStar ::=           Field FieldStar
						| /*epsilon*/
						;

Field ::=               AccessMode VariableDecl
						| AccessMode FunctionDecl
						;

AccessMode ::=          PRIVATE
						| PROTECTED
						| PUBLIC
						| /*epsilon*/
						;

InterfaceDecl ::=       INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES;
PrototypeStar ::=       Prototype PrototypeStar
						| /*epsilon*/
						;

Prototype ::=           Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES;
InsideStmtBlock ::=     VariableDecl InsideStmtBlock
						| StmtStar
						;
StmtStar ::=            Stmt StmtStar
						| /*epsilon*/
						;

Stmt ::=                ExprPrime SEMICOLON
						| IfStmt
						| WhileStmt
						| ForStmt
						| BreakStmt
						| ContinueStmt
						| ReturnStmt
						| PrintStmt
						| StmtBlock
						;

ExprPrime ::=           Expr
						| /*epsilon*/
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e{:
                            int phase = ParserPhase.getInstance().getPhase();
                            System.out.println( IDGenerator.getInstance().getNextID() );
                            if ( phase == 0 )
                                SymbolTable.getInstance().makeNextAndSwitch( SymbolTable.getInstance().getSymbolTable().getScopeName() + "_if");
                            else if ( phase == 1 ) {
                                SymbolTable.getInstance().switchToNext();
                                SemanticStack.getInstance().pushDescriptor( e );
                                IfCodeGen.getInstance().cgen();
                            }
                        :} CLOSEPARENTHESIS Stmt:s {:
                            System.out.println( IDGenerator.getInstance().getNextID() );
                            SymbolTable.getInstance().goBack();
                        :}ElsePrime
                        ;

ElsePrime ::=           ELSE{:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 0 )
                                SymbolTable.getInstance().makeNextAndSwitch( SymbolTable.getInstance().getSymbolTable().getScopeName() + "_if");
                            else if ( phase == 1 ) {
                                SymbolTable.getInstance().switchToNext();
                                String elseLabel = (String)SemanticStack.getInstance().popDescriptor();
                                String endLabel = (String)SemanticStack.getInstance().popDescriptor();
                                CodeGen.getInstance().addToText("b " + endLabel);
                                CodeGen.getInstance().addToText(elseLabel + ":\n", true);
                                SemanticStack.getInstance().pushDescriptor(endLabel);
                            }
                        :} Stmt:s {:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                String endLabel = (String)SemanticStack.getInstance().popDescriptor();
                                CodeGen.getInstance().addToText(endLabel + ":\n", true);
                            }
                            SymbolTable.getInstance().goBack();
                        :}
						| /*epsilon*/ {:
						    int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                String elseLabel = (String)SemanticStack.getInstance().popDescriptor();
                                String endLabel = (String)SemanticStack.getInstance().popDescriptor();
                                CodeGen.getInstance().addToText(elseLabel + ":\n", true);
                            }
                        :}
                        ;

                        //azin is working here and she really has no idea what she's doing
WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e{:
                            SemanticStack.getInstance().popDescriptor();
                            WhileCodeGen.getInstance().cgen();
                        :} CLOSEPARENTHESIS Stmt:s{:
                            String whileLabel = (String)SemanticStack.getInstance().popDescriptor();
                            String endWhileLabel = (String)SemanticStack.getInstance().popDescriptor();
                            CodeGen.getInstance().addToText("b " + whileLabel);
                            CodeGen.getInstance().addToText(endWhileLabel, true);
                        :};

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt;

ReturnStmt ::=          RETURN ExprPrime SEMICOLON;

BreakStmt ::=           BREAK SEMICOLON;

ContinueStmt ::=        CONTINUE SEMICOLON;

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e
                        {:
                            int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								PrintCodeGen.getInstance().cgen();
							}
                        :}
                        PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
						;

PrintCommaExpr ::=      COMMA Expr:e
						{:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								PrintCodeGen.getInstance().cgen();
							}
						:}
						PrintCommaExpr
						|
						/*epsilon*/
						{:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								PrintCodeGen.getInstance().printEnter();
						:}
						;

Expr ::=                LValue:lv ASSIGN Expr:e {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								SemanticStack.getInstance().pushDescriptor( lv );
								AssignmentCodeGen.getInstance().cgen();
//								ParserHelper.getInstance().isLValueArray = false;
							}
							RESULT = new Descriptor( "", Type.DUMMY );
						:}
						|
						Constant:c {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SymbolTable.getInstance().getSymbolTable().addEntry( c.getName(), c );
								Type type = c.getType();
								if ( type == Type.INT || type == Type.DOUBLE || type == Type.BOOL )
									CodeGen.getInstance().addToData(
										c.getName(),
										Type.getMipsType( type ),
										c.getValue().toString()
									);
								else if ( type == Type.STRINGLITERAL ) {
									CodeGen.getInstance().addToData(
										c.getName(),
										Type.getMipsType( type ),
										Integer.toString( c.getValue().toString().length() )
									);
									SemanticStack.getInstance().pushDescriptor( c );
									StringLiteralCodeGen.getInstance().cgen();
								}
							}
							RESULT = c;
						:}
						| LValue:lv {: RESULT = lv; :}
						| THIS
						| Call
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {: RESULT = e; :}
						| Expr:e1 PLUS Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								PlusCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MINUS Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								MinusCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MULTIPLY Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								MultiplyCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 DIVIDE Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								SemanticStack.getInstance().pushDescriptor( "quotient" );
								DivideCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MOD Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                SemanticStack.getInstance().pushDescriptor( "mod" );
                                DivideCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						| MINUS Expr:e {:
							int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                UnaryMinusCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:} %prec UMINUS

                        | Expr:e1 LESS Expr:e2 {:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                LessCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
                        :}
						| Expr:e1 LESSEQUAL Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 LessEqualCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| Expr:e1 GREATER Expr:e2{:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                GreaterCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
                        :}
						| Expr:e1 GREATEREQUAL Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 GreaterEqualCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| Expr:e1 EQUAL Expr:e2{:
                              int phase = ParserPhase.getInstance().getPhase();
                              if ( phase == 1 ) {
                                  SemanticStack.getInstance().pushDescriptor( e1 );
                                  SemanticStack.getInstance().pushDescriptor( e2 );
                                  EqualCodeGen.getInstance().cgen();
                                  Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                  RESULT = temp;
                              }
                          :}
						| Expr:e1 NOTEQUAL Expr:e2{:
                               int phase = ParserPhase.getInstance().getPhase();
                               if ( phase == 1 ) {
                                   SemanticStack.getInstance().pushDescriptor( e1 );
                                   SemanticStack.getInstance().pushDescriptor( e2 );
                                   NotEqualCodeGen.getInstance().cgen();
                                   Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                   RESULT = temp;
                               }
                           :}
						| Expr:e1 AND Expr:e2{:
                              int phase = ParserPhase.getInstance().getPhase();
                              if ( phase == 1 ) {
                                  SemanticStack.getInstance().pushDescriptor( e1 );
                                  SemanticStack.getInstance().pushDescriptor( e2 );
                                  AndCodeGen.getInstance().cgen();
                                  Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                  RESULT = temp;
                              }
                          :}
						| Expr:e1 OR Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 OrCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| NOT Expr:e {:
                          int phase = ParserPhase.getInstance().getPhase();
                          if ( phase == 1 ) {
                              SemanticStack.getInstance().pushDescriptor( e );
                              NotCodeGen.getInstance().cgen();
                              Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                              RESULT = temp;
                          }
                      :}
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
								IntegerInputCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						| NEW IDENTIFIER
						| NEWARRAY OPENPARENTHESIS Expr:e COMMA Type:t CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								ValidArraySizeCheckerCodeGen.getInstance().cgen();
								SemanticStack.getInstance().pushDescriptor( e );
								SemanticStack.getInstance().pushDescriptor( t );
								NewArrayCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								itodCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                dtoiCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						| ITOB OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                itobCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						| BTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                btoiCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						;

LValue ::=              IDENTIFIER:id {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = SymbolTable.getInstance().getSymbolTable().getDescriptor( id );
						:}
						| Expr DOT IDENTIFIER
						| Expr:e1 OPENBRACKET Expr:e2 CLOSEBRACKET {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
//								ParserHelper.getInstance().isLValueArray = true;
								SemanticStack.getInstance().pushDescriptor( e2 );
								SemanticStack.getInstance().pushDescriptor( e1 );
								ArrayGetIndexValueCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						;

Call ::=                IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						| Expr DOT IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						;

Actuals ::=             Expr ActualsCommaExpr
						| /*epsilon*/
						;

ActualsCommaExpr ::=    COMMA Expr ActualsCommaExpr
						| /*epsilon*/
						;

Constant ::=            DECIMAL:d {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.INT,
									Integer.parseInt( d )
								);
						:}
						| FLOATINGPOINT:f {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.DOUBLE,
									Float.floatToIntBits( Float.parseFloat( f ) )
								);
						:}
						| BOOLEANLITERAL:b {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.BOOL,
									( b.equals( "true" ) ) ? 1 : 0 );
						:}
						| STRINGLITERAL:s {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.STRINGLITERAL,
									s.substring( 1, s.length() - 1 ) + '\0'
								);
						:}
						| NULL:n {: RESULT = new CompileTimeDescriptor( "_" + IDGenerator.getInstance().getNextID(), Type.NULL, 0 ); :}
						;

