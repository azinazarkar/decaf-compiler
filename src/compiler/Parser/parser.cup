package compiler.Parser;
import java_cup.runtime.*;
import compiler.Scanner.MyScanner;
import compiler.CodeGenerator.SymbolTable.*;
import compiler.CodeGenerator.Exceptions.*;
import compiler.CodeGenerator.SymbolTable.Utility.*;
import compiler.CodeGenerator.*;
import compiler.CodeGenerator.CodeGen.*;


parser code {:
	private MyScanner scanner;
	public parser (MyScanner scanner){
		this.scanner = scanner;
	}
:}
scan with {: return scanner.next_token(); :}
// defining terminals here
// arithmetic operators
terminal        PLUS, MINUS, MULTIPLY, DIVIDE, MOD, UMINUS,
				LESS, LESSEQUAL, GREATER, GREATEREQUAL, EQUAL, NOTEQUAL;
// logical operators
terminal	    AND, OR, NOT;
// dot
terminal        DOT;
// types
terminal        String INT, DOUBLE, BOOL, STRING;

// literals
terminal        String DECIMAL;
terminal        String FLOATINGPOINT;
terminal        String BOOLEANLITERAL;
terminal        String STRINGLITERAL;
terminal        NULL;

// signs
terminal		OPENBRACKET, CLOSEBRACKET, OPENCLOSEBRACKET, WS, OPENPARENTHESIS,
				CLOSEPARENTHESIS, OPENCURLYBRACES, CLOSECURLYBRACES;
// keywords
terminal        READINTEGER, READLINE, NEW, NEWARRAY, ITOD, DTOI, ITOB, BTOI,
				VOID, CLASS, INTERFACE,
				EXTENDS, IMPLEMENTS, COMMA, SEMICOLON, PRIVATE, PROTECTED, PUBLIC, IF, ELSE, WHILE, FOR, RETURN,
				BREAK, CONTINUE, PRINT, ASSIGN, THIS;
terminal        String IDENTIFIER;

// defining nonterminals
nonterminal     Program, DeclStar, Decl, VariableDecl, Variable, FunctionDecl, Formals, CommaVariables,
				ClassDecl, ClassDeclExtends, ClassDeclImplements, CommaIdentifiers, FieldStar, Field,
				AccessMode, InterfaceDecl, PrototypeStar, Prototype, StmtBlock, InsideStmtBlock, VariableDeclStar, StmtStar,
				Stmt, ExprPrime, IfStmt, ElsePrime, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt, PrintStmt,
				PrintCommaExpr, ActualsCommaExpr, Call, Actuals;
// non-terminals with type
nonterminal     String Type;
nonterminal     Descriptor LValue;
nonterminal     Descriptor Expr;
nonterminal     CompileTimeDescriptor Constant;

// defining precedences
precedence left     ELSE;
precedence right    ASSIGN;
precedence left     OR;
precedence left     AND;
precedence left     EQUAL, NOTEQUAL;
precedence left     LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left     PLUS, MINUS;
precedence left     MULTIPLY, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     DOT, OPENBRACKET;
precedence left     OPENPARENTHESIS;

start with Program;

Program ::=             Decl DeclStar;

DeclStar ::=            Decl DeclStar
						| /*epsilon*/
						;

Decl ::=                VariableDecl
						| FunctionDecl
						| ClassDecl
						| InterfaceDecl
						;

VariableDecl ::=        Variable SEMICOLON;

Variable ::=            Type:t IDENTIFIER:id {:
							if ( ParserPhase.getInstance().getPhase() == 0 ) {
								String name = IDGenerator.getInstance().getNextID();
								Type type = Descriptor.getType( t );
								System.out.println( t );
								SymbolTable.getInstance().getSymbolTable().addEntry(
									id,
									new Descriptor( name, type )
								);
								CodeGen.getInstance().addToData( name, Type.getMipsType( type ), Integer.toString( 0 ) );
							}
						:}
						;

Type ::=                INT {: RESULT = "INT"; :}
						| DOUBLE {: RESULT = "DOUBLE"; :}
						| BOOL {: RESULT = "BOOL"; :}
						| STRING {: System.out.println( "HERE!" ); RESULT = "STRING"; :}
						| IDENTIFIER:e {: RESULT = e; :}
						| Type OPENCLOSEBRACKET {: RESULT = "ARRAY"; :}
						;

FunctionDecl ::=        Type:t IDENTIFIER:name OPENPARENTHESIS {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 0 ) {
								SymbolTable.getInstance().makeNextAndSwitch( name );
							}
							else if ( phase == 1 ) {
								CodeGen.getInstance().addToText( name + ":\n", true );
								SymbolTable.getInstance().switchToNext();
							}
						:}
						Formals {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 0 )
								SymbolTable.getInstance().makeNextAndSwitch();
							else if ( phase == 1 )
								SymbolTable.getInstance().switchToNext();
						:} CLOSEPARENTHESIS StmtBlock {:
							SymbolTable.getInstance().goBack();
							if ( ParserPhase.getInstance().getPhase() == 1 )
								if ( SymbolTable.getInstance().getSymbolTable().getScopeName().equals( "main" )
										&& SymbolTable.getInstance().getSymbolTable().getEntryCount() == 0 ) {
	                                CodeGen.getInstance().addToText( "# Exit!" );
	                                CodeGen.getInstance().addToText( "li $v0, 10" );
	                                CodeGen.getInstance().addToText( "syscall" );
	                                CodeGen.getInstance().addEmptyLine();
	                                CodeGen.getInstance().addEmptyLine();
                                }
							SymbolTable.getInstance().goBack();
						:}
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS StmtBlock
						;

Formals ::=             Variable:v CommaVariables
						| /*epsilon*/
						;
CommaVariables ::=      COMMA Variable CommaVariables
						| /*epsilon*/
						;

ClassDecl ::=           CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements OPENCURLYBRACES FieldStar CLOSECURLYBRACES;
ClassDeclExtends ::=    EXTENDS IDENTIFIER
						| /*epsilon*/
						;
ClassDeclImplements ::= IMPLEMENTS IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
CommaIdentifiers ::=    COMMA IDENTIFIER CommaIdentifiers
						| /*epsilon*/
						;
FieldStar ::=           Field FieldStar
						| /*epsilon*/
						;

Field ::=               AccessMode VariableDecl
						| AccessMode FunctionDecl
						;

AccessMode ::=          PRIVATE
						| PROTECTED
						| PUBLIC
						| /*epsilon*/
						;

InterfaceDecl ::=       INTERFACE IDENTIFIER OPENCURLYBRACES PrototypeStar CLOSECURLYBRACES;
PrototypeStar ::=       Prototype PrototypeStar
						| /*epsilon*/
						;

Prototype ::=           Type IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						| VOID IDENTIFIER OPENPARENTHESIS Formals CLOSEPARENTHESIS SEMICOLON
						;

StmtBlock ::=           OPENCURLYBRACES InsideStmtBlock CLOSECURLYBRACES;
InsideStmtBlock ::=     VariableDecl InsideStmtBlock
						| StmtStar
						;
StmtStar ::=            Stmt StmtStar
						| /*epsilon*/
						;

Stmt ::=                ExprPrime SEMICOLON
						| IfStmt
						| WhileStmt
						| ForStmt
						| BreakStmt
						| ContinueStmt
						| ReturnStmt
						| PrintStmt
						| StmtBlock
						;

ExprPrime ::=           Expr
						| /*epsilon*/
						;

IfStmt ::=              IF OPENPARENTHESIS Expr:e{:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 0 ) {
                                SymbolTable.getInstance().makeNextAndSwitch( "if" );
                            }
                            else if ( phase == 1 ) {
                                SymbolTable.getInstance().switchToNext();
                                SemanticStack.getInstance().pushDescriptor( e );
                                IfCodeGen.getInstance().cgen();
                            }
                        :} CLOSEPARENTHESIS Stmt:s ElsePrime{:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                System.out.println("hey azin");
                                String elseLabel = (String)SemanticStack.getInstance().popDescriptor();
                                CodeGen.getInstance().addToText(elseLabel + ":\n", true);
                            }
                        :};
ElsePrime ::=           ELSE Stmt:s
						| /*epsilon*/
						;
                        //azin is working here and she really has no idea what she's doing
WhileStmt ::=           WHILE OPENPARENTHESIS Expr:e{:
                            SemanticStack.getInstance().popDescriptor();
                            WhileCodeGen.getInstance().cgen();
                        :} CLOSEPARENTHESIS Stmt:s{:
                            String whileLabel = (String)SemanticStack.getInstance().popDescriptor();
                            String endWhileLabel = (String)SemanticStack.getInstance().popDescriptor();
                            CodeGen.getInstance().addToText("b " + whileLabel);
                            CodeGen.getInstance().addToText(endWhileLabel, true);
                        :};

ForStmt ::=             FOR OPENPARENTHESIS ExprPrime SEMICOLON Expr SEMICOLON ExprPrime CLOSEPARENTHESIS Stmt;

ReturnStmt ::=          RETURN ExprPrime SEMICOLON;

BreakStmt ::=           BREAK SEMICOLON;

ContinueStmt ::=        CONTINUE SEMICOLON;

PrintStmt ::=           PRINT OPENPARENTHESIS Expr:e
                        {:
                            int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								PrintCodeGen.getInstance().cgen();
							}
                        :}
                        PrintCommaExpr CLOSEPARENTHESIS SEMICOLON
						;

PrintCommaExpr ::=      COMMA Expr:e
						{:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								PrintCodeGen.getInstance().cgen();
							}
						:}
						PrintCommaExpr
						|
						/*epsilon*/
						{:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								PrintCodeGen.getInstance().printEnter();
						:}
						;

Expr ::=                LValue:lv ASSIGN Expr:e {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								SemanticStack.getInstance().pushDescriptor( lv );
								AssignmentCodeGen.getInstance().cgen();
							}
							RESULT = new Descriptor( "", Type.DUMMY );
						:}
						|
						Constant:c {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SymbolTable.getInstance().getSymbolTable().addEntry( c.getName(), c );
								Type type = c.getType();
								if ( type == Type.INT || type == Type.DOUBLE || type == Type.BOOL )
									CodeGen.getInstance().addToData(
										c.getName(),
										Type.getMipsType( type ),
										c.getValue().toString()
									);
								else if ( type == Type.STRINGLITERAL ) {
									CodeGen.getInstance().addToData(
										c.getName(),
										Type.getMipsType( type ),
										Integer.toString( c.getValue().toString().length() )
									);
									SemanticStack.getInstance().pushDescriptor( c );
									StringLiteralCodeGen.getInstance().cgen();
								}
							}
							RESULT = c;
						:}
						| LValue:lv {: RESULT = lv; :}
						| THIS
						| Call
						| OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {: RESULT = e; :}
						| Expr:e1 PLUS Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								PlusCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MINUS Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								MinusCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MULTIPLY Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								MultiplyCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 DIVIDE Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
							if ( phase == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e1 );
								SemanticStack.getInstance().pushDescriptor( e2 );
								SemanticStack.getInstance().pushDescriptor( "quotient" );
								DivideCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| Expr:e1 MOD Expr:e2 {:
							int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                SemanticStack.getInstance().pushDescriptor( "mod" );
                                DivideCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						| MINUS Expr:e {:
							int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                UnaryMinusCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:} %prec UMINUS

                        | Expr:e1 LESS Expr:e2 {:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                LessCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
                        :}
						| Expr:e1 LESSEQUAL Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 LessEqualCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| Expr:e1 GREATER Expr:e2{:
                            int phase = ParserPhase.getInstance().getPhase();
                            if ( phase == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e1 );
                                SemanticStack.getInstance().pushDescriptor( e2 );
                                GreaterCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
                        :}
						| Expr:e1 GREATEREQUAL Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 GreaterEqualCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| Expr:e1 EQUAL Expr:e2{:
                              int phase = ParserPhase.getInstance().getPhase();
                              if ( phase == 1 ) {
                                  SemanticStack.getInstance().pushDescriptor( e1 );
                                  SemanticStack.getInstance().pushDescriptor( e2 );
                                  EqualCodeGen.getInstance().cgen();
                                  Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                  RESULT = temp;
                              }
                          :}
						| Expr:e1 NOTEQUAL Expr:e2{:
                               int phase = ParserPhase.getInstance().getPhase();
                               if ( phase == 1 ) {
                                   SemanticStack.getInstance().pushDescriptor( e1 );
                                   SemanticStack.getInstance().pushDescriptor( e2 );
                                   NotEqualCodeGen.getInstance().cgen();
                                   Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                   RESULT = temp;
                               }
                           :}
						| Expr:e1 AND Expr:e2{:
                              int phase = ParserPhase.getInstance().getPhase();
                              if ( phase == 1 ) {
                                  SemanticStack.getInstance().pushDescriptor( e1 );
                                  SemanticStack.getInstance().pushDescriptor( e2 );
                                  AndCodeGen.getInstance().cgen();
                                  Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                  RESULT = temp;
                              }
                          :}
						| Expr:e1 OR Expr:e2{:
                             int phase = ParserPhase.getInstance().getPhase();
                             if ( phase == 1 ) {
                                 SemanticStack.getInstance().pushDescriptor( e1 );
                                 SemanticStack.getInstance().pushDescriptor( e2 );
                                 OrCodeGen.getInstance().cgen();
                                 Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                 RESULT = temp;
                             }
                         :}
						| NOT Expr:e {:
                          int phase = ParserPhase.getInstance().getPhase();
                          if ( phase == 1 ) {
                              SemanticStack.getInstance().pushDescriptor( e );
                              NotCodeGen.getInstance().cgen();
                              Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                              RESULT = temp;
                          }
                      :}
						| READINTEGER OPENPARENTHESIS CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
								IntegerInputCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| READLINE OPENPARENTHESIS CLOSEPARENTHESIS
						| NEW IDENTIFIER
						| NEWARRAY OPENPARENTHESIS Expr COMMA Type CLOSEPARENTHESIS
						| ITOD OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
								SemanticStack.getInstance().pushDescriptor( e );
								itodCodeGen.getInstance().cgen();
								Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
								RESULT = temp;
							}
						:}
						| DTOI OPENPARENTHESIS Expr:e CLOSEPARENTHESIS {:
							if ( ParserPhase.getInstance().getPhase() == 1 ) {
                                SemanticStack.getInstance().pushDescriptor( e );
                                dtoiCodeGen.getInstance().cgen();
                                Descriptor temp = (Descriptor) SemanticStack.getInstance().popDescriptor();
                                RESULT = temp;
                            }
						:}
						| ITOB OPENPARENTHESIS Expr CLOSEPARENTHESIS
						| BTOI OPENPARENTHESIS Expr CLOSEPARENTHESIS
						;

LValue ::=              IDENTIFIER:id {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = SymbolTable.getInstance().getSymbolTable().getDescriptor( id );
						:}
						| Expr DOT IDENTIFIER
						| Expr OPENBRACKET Expr CLOSEBRACKET
						;

Call ::=                IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						| Expr DOT IDENTIFIER OPENPARENTHESIS Actuals CLOSEPARENTHESIS
						;

Actuals ::=             Expr ActualsCommaExpr
						| /*epsilon*/
						;

ActualsCommaExpr ::=    COMMA Expr ActualsCommaExpr
						| /*epsilon*/
						;

Constant ::=            DECIMAL:d {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.INT,
									Integer.parseInt( d )
								);
						:}
						| FLOATINGPOINT:f {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.DOUBLE,
									Float.floatToIntBits( Float.parseFloat( f ) )
								);
						:}
						| BOOLEANLITERAL:b {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.BOOL,
									( b.equals( "true" ) ) ? 1 : 0 );
						:}
						| STRINGLITERAL:s {:
							if ( ParserPhase.getInstance().getPhase() == 1 )
								RESULT = new CompileTimeDescriptor(
									"_" + IDGenerator.getInstance().getNextID(),
									Type.STRINGLITERAL,
									s.substring( 1, s.length() - 1 ) + '\0'
								);
						:}
						| NULL:n {: RESULT = new CompileTimeDescriptor( "_" + IDGenerator.getInstance().getNextID(), Type.NULL, 0 ); :}
						;

